<script type="text/javascript">

    var remaining_turns = {{ remaining_turns }};
    //const socket_name = '{{socket_name}}'
    const cur_user_id = '{{cur_user.id}}'
    const reply_as_user = '{{reply_as_user}}'
    let thread =
    {{ thread_json| safe}}  // json data
    const user_data = {user_name: '{{cur_user.name}}', user_id: '{{cur_user.id}}', thread_id: '{{thread.id}}'}
    const BOT_ID = 'Moderator'
    const show_text_extra = Boolean({{ 'true' if show_text_extra else 'false' }})
    const user_to_name = new Map(thread['users'].map(u => [u['id'], u['name']]))
    // all_speaker_ids are moved to global scope, so that the bubble color can be found in AJAX (getMessages)
    // all_speaker_ids is a list of all speaker_id's in the current thread. It does not include any duplicated elements.
    const all_speaker_ids = []
    // If waiting_for_other_human_reply is true, then the user is not allowed to send any messages.
    let waiting_for_bot_reply = false
    // Not used in the current version.
    let waiting_for_other_human_reply = false
    // prev_user_id is the user_id of the latest message.
    // It is used to determine if the current human user is the "2nd human" in a 2-human conversation.
    // Not used in the current version.
    var prev_user_id;
    // Record the ChatMessage.id of the latest message locally.
    var cur_message_id;
    var need_moderator_bot = {{ thread.need_moderator_bot|lower }};

    /**
     * Dynamically show a new message in the chat window.
     * @param msg a json file containing the message to be shown.
     */
    function show_new_message(msg) {

        const colors = ["secondary", "light", "dark", "info", "primary"]

        if (!msg['data']) {
            msg['data'] = new Object()
        }
        //let theme = side == 'right' ? 'alert-primary' : 'alert-warning'
        let display_user = msg['data']['fake_start'] ? msg['data']['speaker_id'] : user_to_name.get(msg['user_id'])
        if (msg['user_id'] == cur_user_id && reply_as_user) {
            display_user = `<i>Your reply as</i> ${reply_as_user}`
        }

        let theme = ''
        let side = 'left'
        // If the message is from the current human user.
        if (msg['user_id'] == cur_user_id || msg['data']['speaker_id'] == reply_as_user) {
            theme = 'alert-danger'
            side = 'right'
            // If the message is from the bot.
        } else if (msg['user_id'] == BOT_ID) {
            theme = 'alert-success'
        } else {
            // If the message is from another human user, or chat history.
            let cur_speaker_id = msg['data']['speaker_id'];
            // If the current message is from AJAX "get_latest_messages",
            // then the speaker_id is not included in the message json.
            // But we can still get the speaker_id from the user_to_name map.
            if (cur_speaker_id === undefined) {
                cur_speaker_id = user_to_name.get(msg['user_id']);
            }
            for (let i = 0; i < all_speaker_ids.length; i++) {
                if (cur_speaker_id == all_speaker_ids[i]) {
                    let set_color = colors[i % colors.length]
                    theme = 'alert-' + set_color
                }
            }
        }

        let text_display = msg['text']
        let text_extra = msg['data']['text_orig']
        if (text_extra && msg['user_id'] != BOT_ID) {
            [text_extra, text_display] = [text_display, text_extra]
        }

        if (text_extra && show_text_extra) {
            text_display = `<details>
                    <summary>${text_display}</summary>
                    <i class="text-muted">${text_extra}</i>
                </details>`
        }
        let tmp_id = msg['id'];
        if (tmp_id === undefined) {
            tmp_id = ++cur_message_id;
        }
        let chat_html = `<li style="width:100%" id = "chat-message-${tmp_id}">
                <div class="card ${theme} mb-4" style="float:${side}; width:75%">
                    <div class="card-header d-flex justify-content-between p-2">
                        <p class="fw-bold mb-0"> ${display_user} </p>
                        <p class="text-muted small mb-0"><i class="far fa-clock"></i>${msg['time_created']}</p>
                    </div>
                    <div class="card-body" style="padding: 0.5em">
                        ${text_display}
                    </div>
                </div>
            </li>`
        $('#chat-thread').append($.parseHTML(chat_html))
        refresh_view()
    }

    /**
     * Hide or show the message input form, the waiting animation, and the end survey.
     */
    function refresh_view() {
        scroll_chat_to_bottom();
        $('#ratings-view').hide()
        if (remaining_turns < 1 || Boolean({{ 'true' if cur_user.is_admin else 'false' }})) {

            // if the current user is the moderator, delete the form
            if (reply_as_user == "Moderator") {
                // delete all content of ratings-form
                $('#ratings-form').empty()
                waiting_for_other_human_reply = false;
                waiting_for_bot_reply = false;
            }

            console.log("waiting_for_other_human_reply: ", waiting_for_other_human_reply)
            console.log("waiting_for_bot_reply: ", waiting_for_bot_reply)
            if (!((need_moderator_bot && waiting_for_bot_reply) || waiting_for_other_human_reply)) {
                $('#end_info').show() // show end info
                $('#next_msg_form').hide()
                $('#waiting_info').hide()
                $('#ratings-view').show()
            }

        } else { // ongoing conversation
            $('#end_info').hide()
            if (waiting_for_bot_reply || waiting_for_other_human_reply) { // but wating for bot or other human reply
                $('#next_msg_form').hide()  // dont let human reply
                $('#waiting_info').show()  // waiting animation show
            } else {
                $('#next_msg_form').show() // let human reply
                $('#waiting_info').hide() // waiting animation hide
            }
        }
    }

    function play_beep() {
        new Audio('{{url_for("app.static", filename="img/new_message_beep.mp3")}}').play();
    }


    /**
     * The "main" function to be called when the page is loaded.
     */
    window.onload = () => {
        update_speaker_ids();
        get_messages();

        block_second_user_first_turn(thread);
        /**
         * Here we get the speaker ids of all the users in the conversation, and put them in all_speaker_ids.
         The speaker ids are used to set the color of the message bubble (see the function show_new_message).

         Their color will be colors[i % colors.length], where i is the index of the speaker id in all_speaker_ids.
         Actually, we should use a set to first store all the speaker_ids, and then convert the set to an array.
         But I don't want to change the logic of the original developer.
         */

        for (const msg of thread['messages']) {
            this_user_id = msg['data']['speaker_id']
            add_element = true
            for (let i = 0; i < all_speaker_ids.length; i++) {
                if (all_speaker_ids[i] == this_user_id) {
                    add_element = false
                }
            }
            if (add_element == true) {
                all_speaker_ids.push(this_user_id)
            }
        }
        for (const msg of thread['messages']) {
            show_new_message(msg)
        }
        if (thread['messages'].length > 0) {
            cur_message_id = thread['messages'][thread['messages'].length - 1]['id'];
        } else {
            cur_message_id = 0;
        }


        /**
         * Logic unused for now.
         * When the page is reloaded, the wait_for_other_human_reply flag will be reset. So we need to check it again.
         * If the last message is from the current user, then the current user is waiting for the other human user to reply.
         */
        {#let message_list = thread['messages'];#}
        {#prev_user_id = message_list[message_list.length - 1]['user_id'];#}
        {#if (prev_user_id === cur_user_id) {#}
        {#    waiting_for_other_human_reply = true;#}
        //}
        refresh_view();

        // include cross-origin session details with ajax calls
        $.ajaxSetup({
            crossDomain: true,
            xhrFields: {
                withCredentials: true
            },
        });



        // initial submit
        // if there is no message in the thread that is from a user with BOT_ID, submit
        if (need_moderator_bot === true && !thread['messages'].some(msg => msg['user_id'] == BOT_ID)) {
            waiting_for_bot_reply = true
            refresh_view()
            console.log("submitting initial message...")

            var post_url = '{{url_for("app.post_current_thread", thread_id=thread.id, user_id=cur_user.id)}}'
            $.post(post_url).done(reply => {
                console.log(reply)
                try {
                    waiting_for_bot_reply = false
                    if (reply['text'] != "") {
                        console.log("showing bot reply: ", reply['text'])
                        msg_id = show_new_message(reply)
                        play_beep();
                    } else {
                        // Unblock the current user.
                        refresh_view();
                    }
                } catch {
                    alert('Something went wrong. See logs.')
                }
            }).fail(function () {
                alert('Something went wrong. Could not send message.')
            })
        }

        $("#next_msg_text").keyup(event => {  // submit on enter key
            if (event.which === 13) {
                $("#next_msg_form").submit();
            }
        });
        // When user submits a new message.
        $("#next_msg_form").submit(event => {
            event.preventDefault();
            var text = $('#next_msg_text').val().trim()
            if (!text) {
                console.log('No text to send')
                return
            }
            waiting_for_other_human_reply = true
            waiting_for_bot_reply = true

            data = {'text': text, time_created: new Date().toISOString()}
            data = {...user_data, ...data}  //combine two

            msg_id = show_new_message(data, side = 'right')
            console.log("before posted")
            var post_url = '{{url_for("app.post_new_message", thread_id=thread.id, user_id=cur_user.id)}}'
            $.post(post_url, {text: text, speaker_id: reply_as_user}).done(reply => {
                $('#next_msg_text').val('')
                console.log("posted")
                try {
                    remaining_turns--;
                    if (reply['episode_done']) {
                        remaining_turns = 0;
                    }
                    $('#remaining-turns-count').html(remaining_turns);

                    waiting_for_bot_reply = false

                    // If the bot's reply is not empty, show it.
                    console.log("bot reply: ", reply)
                    if (reply['text'] != "") {
                        console.log("showing bot reply: ", reply['text'])
                        msg_id = show_new_message(reply)
                    } else {
                        // Unblock the current user.
                        refresh_view();
                    }
                    {#prev_user_id = cur_user_id;#}
                    // play_beep();
                } catch {
                    alert('Something went wrong. See logs.')
                }
            }).fail(function () {
                alert('Something went wrong. Could not send message.')
            })
        })
    }

    function is_second_user(thread) {
        // if cur_user_id = id of last message with is_seed = true
        var need_moderator_bot = {{ thread.need_moderator_bot|lower }};
        console.log("need_moderator_bot is: ", need_moderator_bot)

        if (need_moderator_bot === false) {
            if (reply_as_user === "Moderator") {
                return false
            } else {
                return true
            }
        }

        last_seed_message = thread['messages'].filter(m => m['is_seed']).slice(-1)[0]
        console.log(last_seed_message, cur_user_id, reply_as_user)
        if (last_seed_message['data']['speaker_id'] !== reply_as_user) {
            return true
        } else {
            return false
        }
    }

    function block_second_user_first_turn(thread) {
        var need_moderator_bot =
        {{thread.need_moderator_bot|lower}}
        // if bot's first response is in

        if (need_moderator_bot === false) {
            if (is_second_user(thread) && thread['messages'].every(m => m['is_seed'])) {
                waiting_for_other_human_reply = true;
                refresh_view();
                console.log("should block")
                return
            }
        } else {
            if (is_second_user(thread)) {
                if (
                    (!thread['messages'][thread['messages'].length - 1]['is_seed'] && thread['messages'].slice(0, -1).every(m => m['is_seed'])) ||
                    thread['messages'].every(m => m['is_seed'])) {
                    console.log("in block condition")
                    waiting_for_other_human_reply = true;
                    refresh_view();
                    console.log("should block")
                    return
                }
            }
        }


        console.log("should not block")
    }

    function ratings_validation() {
        let invalid = false
        for (const el of $('#ratings-form').find(":input[type='range']")) {
            if (el.value == el.min) {
                el.parentNode.classList.add('bg-warning')
                invalid = true
            } else {
                el.parentNode.classList.remove('bg-warning')
            }
        }
        if (invalid) {
            alert('Please provide your rating to ALL questions.')
            event.preventDefault();
        }
    }

    /**
     * We need to store "which human user is playing which role (speaker abcdef...)" in the conversation.
     */
    function update_speaker_ids() {
        Object.keys(thread['speakers']).forEach(key => {
            user_to_name.set(key, thread['speakers'][key]);
        })
    }

    /**
     * The AJAX call every 5 seconds.
     */
    function get_messages() {
        fetch({{ url_for("app.get_thread_object", thread_id=thread.id) |tojson}})
            .then(response => response.json())
            .then(data => {

                // if the number of messages in the thread is different from the number of messages loaded from thread
                if (data['messages'].length !== thread['messages'].length) {
                    render_message_list(data);


                    /**
                     * If the length of data is longer than the length of thread, the user should be notified (new message).
                     * But there are 2 corner cases:
                     * 1. The last message is from the current user, but we haven't updated it to the local thread object yet.
                     * 2. The last message is from the bot, replying to current user's last message.
                     */
                    /* if (data['messages'].length > thread['messages'].length &&
                        data['messages'][data['messages'].length - 1]['user_id'] !== cur_user_id &&
                        !(data['messages'][data['messages'].length - 1]['user_id'] === BOT_ID &&
                            data['messages'][data['messages'].length - 2]['user_id'] === cur_user_id)) {
                        play_beep();
                    }
                    */


                    /**
                     * At the beginning of the 2-user conversation, the 2nd human user should be blocked.
                     * The 2nd human user plays the role of the second last speaker in the conversation history.
                     */
                    // if the latest message's is_seed is false and all the others are true


                    console.log(data['messages'][data['messages'].length - 1]['user_id'], cur_user_id, BOT_ID)
                    // if the last message is from the other user
                    if (data['messages'][data['messages'].length - 1]['user_id'] !== BOT_ID && data['messages'][data['messages'].length - 1]['user_id'] !== cur_user_id) {
                        waiting_for_other_human_reply = false;
                        refresh_view();
                        play_beep();
                    }

                    thread = data; // update thread object
                    // If the current human user is the 1st one entering the chatroom, user_to_name map doesn't
                    // have the 2nd human user's speaker id. So we need to update it.
                    update_speaker_ids();
                    cur_message_id = thread['messages'][thread['messages'].length - 1]['id'];
                }

                if (data['messages'].length > 0 &&
                    ((data['messages'][data['messages'].length - 2]['user_id'] === cur_user_id && data['messages'][data['messages'].length - 1]['user_id'] === BOT_ID) ||
                    data['messages'][data['messages'].length - 1]['user_id'] === cur_user_id)) {
                    waiting_for_other_human_reply = true;
                    refresh_view();
                }
            });
    }

    function render_message_list(thread_object) {
        /*** The message list is fetched every 5 seconds. What if the other user sends > 1 message in the past
         5 seconds? In that case, the cur_message_id is not the real last message id in the backend.

         For example, if the latest message id is 10 and the current user is going to send a new message, the new
         message id should be 11. However, if the other user and bot sent 2 messages in the past 5 seconds as well,
         the correct id might be 13 instead of 11.

         Illustration of what actually happened:
         ajax_call ->
         other user message (id = 11) ->
         bot reply (id = 12) ->
         current user message (id = 13) (but we don't know it should be 13 before the next ajax call. We thought it's 11) ->
         ajax_call

         So, we need to delete all the messages to cope with such corner cases.
         */
        $("#chat-thread").empty();

        // Render/update all the messages.
        thread_object['messages'].forEach(msg => {
            if ($("#chat-message-" + msg['id'])[0] == null) {
                show_new_message(msg);
            }
        });
    }

    // Update the chat thread every 5 seconds.
    if (!Boolean({{ 'true' if cur_user.is_admin else 'false' }})) {
        window.setInterval(get_messages, 1000);
    }

    // Automatically scroll to the bottom of the chat box.
    function scroll_chat_to_bottom() {
        const chat_thread = document.getElementById('chat-thread');
        chat_thread.scrollTop = chat_thread.scrollHeight;
        {#$("#chat-thread").animate({scrollTop: $("#chat-thread").height()}, 'slow')#}
    }
</script>